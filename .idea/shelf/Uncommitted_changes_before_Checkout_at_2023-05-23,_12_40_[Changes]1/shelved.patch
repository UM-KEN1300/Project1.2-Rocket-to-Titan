Index: src/main/java/code/algorithms/Solvers.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package code.algorithms;\n\nimport code.model.objects.PlanetObject;\nimport code.utils.HelperFunctions;\n\nimport java.util.ArrayList;\n\npublic class Solvers {\n    final static double G = PlanetObject.G;\n\n\n    private Solvers() {\n    }\n\n\n    public static double accelerationForSolvers(double position1D, PlanetObject planetObject, PlanetObject otherObject, int i) {\n        double force = 0;\n        double acceleration = 0;\n        double M1 = planetObject.getMass();\n        double M2 = otherObject.getMass();\n        double positionalDifference = 0;\n        double[] coordinates = planetObject.getCoordinates();\n        double[] otherCoordinates = otherObject.getCoordinates();\n\n        positionalDifference = position1D - otherCoordinates[i];\n\n        double distance = 1 / HelperFunctions.getDistanceBetweenWithVectors(coordinates, otherCoordinates);\n\n        force = -G * M1 * M2 * (Math.pow(distance, 3)) * positionalDifference;\n        acceleration = force / M1;\n\n        return acceleration;\n    }\n\n     public static void explicitEuler(PlanetObject planetObject, PlanetObject otherObject, double h) {\n        double[] velocity = planetObject.getVelocity();\n        double[] coordinates = planetObject.getCoordinates();\n        double[] acceleration = planetObject.getAcceleration();\n\n        for (int i = 0; i < 3; i++) {\n            acceleration[i] += accelerationForSolvers(coordinates[i], planetObject, otherObject, i);\n            coordinates[i] += velocity[i] * h;\n            velocity[i] += acceleration[i] * h;\n        }\n\n        planetObject.setVelocity(velocity);\n        planetObject.setCoordinates(coordinates);\n        planetObject.setAcceleration(acceleration);\n    }\n\n//    public static double accelerationForSolversV(double velocity1D, PlanetObject planetObject, PlanetObject otherObject, int i) {\n//        double force = 0;\n//        double acceleration = 0;\n//        double M1 = planetObject.getMass();\n//        double M2 = otherObject.getMass();\n//        double velocityDifference = 0;\n//        double[] velocity = planetObject.getVelocity();\n//        double[] otherVelocity = otherObject.getVelocity();\n//\n//        velocityDifference = velocity1D - otherVelocity[i];\n//\n//        double velocity = 1 / HelperFunctions.getDistanceBetweenWithVectors(velocity, otherVelocity);\n//\n//        force = -G * M1 * M2 * (Math.pow(velocity, 3)) * velocityDifference;\n//        acceleration = force / M1;\n//\n//        return acceleration;\n//    }\n//\n//    /**\n//     * @param acceleration is the all the accelerations that affect a planet\n//     * @param step         is amount of time we move the planet 1 second is 1\n//     *                     <p>\n//     *                     This is the Euler's solver that updates the planet position with step in time\n//     */\n//    public static void implicitEuler(PlanetObject planetObject, double[] acceleration, double step) {\n//        double[] velocity = planetObject.getVelocity();\n//        double[] coordinates = planetObject.getCoordinates();\n//        for (int i = 0; i < 3; i++) {\n//            velocity[i] += acceleration[i] * step;\n//            coordinates[i] += velocity[i] * step;\n//        }\n//        planetObject.setVelocity(velocity);\n//        planetObject.setCoordinates(coordinates);\n//    }\n//\n//\n//    public static void rungeKutta4(PlanetObject planetObject, PlanetObject otherObject, double h) {\n//        double[] velocity = planetObject.getVelocity();\n//        double[] coordinates = planetObject.getCoordinates();\n//        double[] acceleration = planetObject.getAcceleration();\n//        double[] kr1 = new double[3];\n//        double[] kr2 = new double[3];\n//        double[] kr3 = new double[3];\n//        double[] kr4 = new double[3];\n//        double[] kv1 = new double[3];\n//        double[] kv2 = new double[3];\n//        double[] kv3 = new double[3];\n//        double[] kv4 = new double[3];\n//\n//        for (int i = 0; i < 3; i++) {\n//            kv1[i] = acceleration[i] + accelerationForSolvers(coordinates[i], planetObject, otherObject, i);\n//            kr1[i] = velocity[i];\n//            kv2[i] = acceleration[i] + accelerationForSolvers(coordinates[i] + (kr1[i] * (h / 2)), planetObject, otherObject, i);\n//            kr2[i] = velocity[i] * (kv1[i] * (h / 2));\n//            kv3[i] = acceleration[i] + accelerationForSolvers(coordinates[i] + (kr2[i] * (h / 2)), planetObject, otherObject, i);\n//            kr3[i] = velocity[i] * (kv2[i] * (h / 2));\n//            kv4[i] = acceleration[i] + accelerationForSolvers(coordinates[i] + (kr3[i] * (h / 2)), planetObject, otherObject, i);\n//            kr4[i] = velocity[i] * (kv3[i] * h);\n//\n//            velocity[i] = velocity[i] + (h / 6) * (kv1[i] + 2 * kv2[i] + 2 * kv3[i] + kv4[i]);\n//            coordinates[i] = coordinates[i] + (h / 6) * (kr1[i] + 2 * kr2[i] + 2 * kr3[i] + kr4[i]);\n//        }\n//        double newAcceleration[] = new double[3];\n//        newAcceleration = HelperFunctions.addition(newAcceleration, planetObject.accelerationBetween(otherObject));\n//\n//        planetObject.setVelocity(velocity);\n//        planetObject.setCoordinates(coordinates);\n//        //planetObject.setAcceleration(newAcceleration);\n//\n//        System.out.println(\"x: \" + planetObject.getAcceleration(0));\n//        System.out.println(\"y: \" + planetObject.getAcceleration(1));\n//        System.out.println(\"z: \" + planetObject.getAcceleration(2));\n//    }\n//\n//\n//    public void adamsMoulton(PlanetObject planetObject, PlanetObject otherObject, double h) {\n//        double[] velocity = planetObject.getVelocity();\n//        double[] coordinates = planetObject.getCoordinates();\n//        double[] acceleration = planetObject.getAcceleration();\n//\n//        for (int i = 1; i < 4; i++) {\n//            acceleration[i] += accelerationForSolvers(coordinates[i], planetObject, otherObject, i);\n//            coordinates[i] += (h / 2) * (3 * velocity[i] - velocity[i - 1]);\n//        }\n//\n//    }\n//\n//    public static void kutta3(PlanetObject planetObject, PlanetObject otherObject, double h) {\n//        double[] velocity = planetObject.getVelocity();\n//        double[] coordinates = planetObject.getCoordinates();\n//        double[] acceleration = planetObject.getAcceleration();\n//        double[] kv1 = new double[3];\n//        double[] kv2 = new double[3];\n//        double[] kv3 = new double[3];\n//        double[] kr1 = new double[3];\n//        double[] kr2 = new double[3];\n//        double[] kr3 = new double[3];\n//\n//        for (int i = 0; i < 3; i++) {\n//            kr1[i] = h * velocity[i];\n//            kv1[i] = acceleration[i] + (h * accelerationForSolvers(coordinates[i], planetObject, otherObject, i));\n//            kr2[i] = h * (velocity[i] + kv1[i] / 2);\n//            kv2[i] = acceleration[i] + (h * accelerationForSolvers(kr1[i] / 2, planetObject, otherObject, i));\n//            kr3[i] = h * (velocity[i] - kv2[i] + 2 * kv1[i]);\n//            kv3[i] = acceleration[i] + (h * accelerationForSolvers(coordinates[i] + kr2[i], planetObject, otherObject, i));\n//\n//            coordinates[i] += (1 / 6) * (kr1[i] + 4 * kr2[i] + kr3[i]);\n//            velocity[i] += (1 / 6) * (kv1[i] + 4 * kv2[i] + kv3[i]);\n//        }\n//\n//        double[] newAcceleration = new double[3];\n//        newAcceleration = HelperFunctions.addition(newAcceleration, planetObject.accelerationBetween(otherObject));\n//        planetObject.setCoordinates(coordinates);\n//        planetObject.setVelocity(velocity);\n//        //planetObject.setAcceleration(newAcceleration);\n//\n//    }\n\n\n//    public static void ralston2(PlanetObject planetObject, PlanetObject otherObject, double h) {\n//        double[] velocity = planetObject.getVelocity();\n//        double[] coordinates = planetObject.getCoordinates();\n//        double[] acceleration = planetObject.getAcceleration();\n//        double kv1[] = new double[3];\n//        double kv2[] = new double[3];\n//        double kr1[] = new double[3];\n//        double kr2[] = new double[3];\n//\n//        for (int i = 0; i < 3; i++) {\n//            kv1[i] = acceleration[i] + accelerationForSolvers(coordinates[i], planetObject, otherObject, i);\n//            kr1[i] = velocity[i];\n//            kv2[i] = acceleration[i] + accelerationForSolvers(coordinates[i] + (kr1[i] * (2 * h / 3)), planetObject, otherObject, i);\n//            kr2[i] = velocity[i] * (kv1[i] * (2 * h / 3));\n//\n//            velocity[i] = velocity[i] + (h / 4) * (kv1[i] + 3 * kv2[i]);\n//            coordinates[i] = coordinates[i] + (h / 4) * (kr1[i] + 3 * kr2[i]);\n//        }\n//\n//        double newAcceleration[] = new double[3];\n//        newAcceleration = HelperFunctions.addition(newAcceleration, planetObject.accelerationBetween(otherObject));\n//\n//        planetObject.setVelocity(velocity);\n//        planetObject.setCoordinates(coordinates);\n//        planetObject.setAcceleration(newAcceleration);\n//\n//\n//    }\n\n\n//    public static void midPoint(PlanetObject planetObject, PlanetObject otherObject, double h) {\n//        double[] velocity = planetObject.getVelocity();\n//        double[] coordinates = planetObject.getCoordinates();\n//        double[] newCoordinates = new double[3];\n//        double[] newVelocity = new double[3];\n//        double[] acceleration = planetObject.getAcceleration();\n//        double[] kv1 = new double[3];\n//        double[] newAcceleration = new double[3];\n//\n//\n//        for (int i = 0; i < 3; i++) {\n//            kv1[i] = acceleration[i] + (0.5 * accelerationForSolvers(coordinates[i], planetObject, otherObject, i) * h);\n//            newCoordinates[i] = coordinates[i] + (0.5 * velocity[i] * h);\n//            newVelocity[i] = velocity[i] + kv1[i];\n//        }\n//        for (int i = 0; i < 3; i++) {\n//            kv1[i] = acceleration[i] + (accelerationForSolvers(newCoordinates[i], planetObject, otherObject, i) * h);\n//            velocity[i] = velocity[i] + acceleration[i];\n//            coordinates[i] = coordinates[i] + (newVelocity[i] * h);\n//        }\n//\n//        newAcceleration = HelperFunctions.addition(newAcceleration, planetObject.accelerationBetween(otherObject));\n//\n//        planetObject.setVelocity(velocity);\n//        planetObject.setCoordinates(coordinates);\n//\n//        /*System.out.println(\"x: \"+planetObject.getAcceleration(0));\n//        System.out.println(\"y: \"+planetObject.getAcceleration(1));\n//        System.out.println(\"z: \"+planetObject.getAcceleration(2));*/\n//        planetObject.setAcceleration(newAcceleration);\n//    }\n\n        /*for (int i = 0; i < 3; i++){\n            coordinates[i] += h * accelerationForSolvers(coordinates[i]+(1/2)*h*accelerationForSolvers(coordinates[i], planetObject, otherObject, i), planetObject, otherObject, i);\n            velocity[i] += h * accelerationForSolvers(velocity[i]+(1/2)*h*accelerationForSolvers(velocity[i], planetObject, otherObject, i), planetObject, otherObject, i);\n        }*/\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/code/algorithms/Solvers.java b/src/main/java/code/algorithms/Solvers.java
--- a/src/main/java/code/algorithms/Solvers.java	
+++ b/src/main/java/code/algorithms/Solvers.java	
@@ -1,12 +1,13 @@
 package code.algorithms;
 
+import code.model.objects.ModeledObject;
 import code.model.objects.PlanetObject;
 import code.utils.HelperFunctions;
 
 import java.util.ArrayList;
 
 public class Solvers {
-    final static double G = PlanetObject.G;
+    final static double G = ModeledObject.G;
 
 
     private Solvers() {
Index: src/main/java/code/graphics/solar_system/controllers/SolarScrollController.java
===================================================================
diff --git a/src/main/java/code/graphics/solar_system/controllers/SolarScrollController.java b/src/main/java/code/graphics/solar_system/controllers/SolarScrollController.java
new file mode 100644
--- /dev/null	
+++ b/src/main/java/code/graphics/solar_system/controllers/SolarScrollController.java	
@@ -0,0 +1,23 @@
+package code.graphics.solar_system.controllers;
+
+import code.graphics.solar_system.SolarSubScene;
+import javafx.scene.PerspectiveCamera;
+import javafx.scene.input.ScrollEvent;
+
+public class SolarScrollController {
+    private final PerspectiveCamera camera;
+
+    public SolarScrollController(SolarSubScene solarSubScene) {
+        this.camera = (PerspectiveCamera) solarSubScene.getCamera();
+        addScrollHandler(solarSubScene);
+    }
+
+    private void addScrollHandler(SolarSubScene solarSubScene) {
+        solarSubScene.addEventHandler(ScrollEvent.SCROLL, event -> {
+            double deltaY = event.getDeltaY();
+
+            camera.setTranslateZ(camera.getTranslateZ() - deltaY * camera.getTranslateZ() * 0.001);
+            solarSubScene.updateSizes();
+        });
+    }
+}
Index: src/main/java/code/graphics/solar_system/controllers/SolarMouseController.java
===================================================================
diff --git a/src/main/java/code/graphics/solar_system/controllers/SolarMouseController.java b/src/main/java/code/graphics/solar_system/controllers/SolarMouseController.java
new file mode 100644
--- /dev/null	
+++ b/src/main/java/code/graphics/solar_system/controllers/SolarMouseController.java	
@@ -0,0 +1,35 @@
+package code.graphics.solar_system.controllers;
+
+import code.graphics.solar_system.SolarSubScene;
+import javafx.scene.Group;
+import javafx.scene.Scene;
+import javafx.scene.transform.Rotate;
+
+public class SolarMouseController {
+    private double anchorX, anchorY;
+    private double anchorAngleX, anchorAngleZ;
+    private final Rotate xRotate, zRotate;
+
+    public SolarMouseController(SolarSubScene solarSubScene, Scene scene) {
+        Group root = (Group) solarSubScene.getRoot();
+        xRotate = new Rotate(-45, Rotate.X_AXIS);
+        zRotate = new Rotate(0, Rotate.Z_AXIS);
+
+        root.getTransforms().addAll(xRotate, zRotate);
+
+        scene.setOnMousePressed(event -> {
+            anchorX = event.getSceneX();
+            anchorY = event.getSceneY();
+            anchorAngleX = xRotate.getAngle();
+            anchorAngleZ = zRotate.getAngle();
+        });
+
+        scene.setOnMouseDragged(event -> {
+            double deltaX = event.getSceneX() - anchorX;
+            double deltaY = event.getSceneY() - anchorY;
+
+            xRotate.setAngle(anchorAngleX + deltaY*0.2);
+            zRotate.setAngle(anchorAngleZ - deltaX*0.2);
+        });
+    }
+}
Index: src/main/java/code/graphics/solar_system/SolarSubScene.java
===================================================================
diff --git a/src/main/java/code/graphics/solar_system/SolarSubScene.java b/src/main/java/code/graphics/solar_system/SolarSubScene.java
new file mode 100644
--- /dev/null	
+++ b/src/main/java/code/graphics/solar_system/SolarSubScene.java	
@@ -0,0 +1,93 @@
+package code.graphics.solar_system;
+
+import code.graphics.solar_system.controllers.SolarScrollController;
+import code.graphics.solar_system.objects.SolarGroup;
+import code.model.Model;
+import code.model.objects.PlanetObject;
+import javafx.scene.Group;
+import javafx.scene.PerspectiveCamera;
+import javafx.scene.SceneAntialiasing;
+import javafx.scene.SubScene;
+import javafx.scene.paint.Color;
+import javafx.scene.shape.Sphere;
+import javafx.scene.transform.Rotate;
+import javafx.scene.transform.Translate;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import static code.graphics.Visualizer.SCALE;
+
+/**
+ * Class responsible for creating and managing the movement of the 3D objects in the visualization.
+ */
+public class SolarSubScene extends SubScene {
+    private final SolarGroup ROOT;
+    private final Map<String, Sphere> celestialBodyViews;
+    private final Map<String, Double> CELESTIAL_BODY_SIZES;
+    private final Map<String, PlanetObject> CELESTIAL_BODIES;
+
+
+    public SolarSubScene(SolarGroup root, double width, double height) {
+        super(root, width, height, true, SceneAntialiasing.BALANCED);
+        ROOT = root;
+        CELESTIAL_BODIES = Model.getPlanetObjects();
+
+        celestialBodyViews = new HashMap<>();
+        CELESTIAL_BODY_SIZES = new HashMap<>();
+
+        initializeSubScene();
+    }
+
+    private void initializeSubScene() {
+        setFill(Color.BLACK.brighter());
+        initializeCamera();
+        initializeFilters();
+    }
+
+    private void initializeCamera() {
+        PerspectiveCamera camera = new PerspectiveCamera(true);
+        camera.setNearClip(0.01);
+        camera.setFarClip(1_000_000_000);
+        camera.setTranslateZ(-celestialBodyViews.get("Sun").getRadius());
+        setCamera(camera);
+        updateSizes();
+    }
+
+    private void initializeFilters() {
+        new SolarScrollController(this);
+        setRotationPoint(0, 0, 0);
+    }
+
+    /**
+     * Updates the positions of all 3D objects representations.
+     */
+    public void updateCoordinates() {
+
+    }
+
+    public void setRotationPoint(double x, double y, double z) {
+        ROOT.getTransforms().setAll(new Translate(-x, -y, -z), new Rotate(), new Translate(x, y, z));
+    }
+
+    public void updateSizes() {
+        double cameraZ = -getCamera().getTranslateZ(); // Make sure cameraZ is positive
+        double scaleFactor;
+        double zoomLevel = cameraZ / (2000.0 * SCALE);
+
+        for (Map.Entry<String, Sphere> entry : celestialBodyViews.entrySet()) {
+            String key = entry.getKey();
+            Sphere view = entry.getValue();
+            double minSize = CELESTIAL_BODY_SIZES.get(key) / SCALE; // Get the minimum size and apply the scaling factor
+
+            scaleFactor = 1 + 2 * zoomLevel;
+            scaleFactor = Math.max(1, scaleFactor); // Prevent the scaleFactor from going below 1
+
+            if (key.equals("Sun")) {
+                scaleFactor = scaleFactor * 0.03; // Apply a different scaling factor for the Sun
+            }
+
+            view.setRadius(minSize * scaleFactor);
+        }
+    }
+}
