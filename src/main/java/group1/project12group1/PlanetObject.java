package Model;

import helperFunction.HelperFunctions;

public class PlanetObject
{
    //Variables

    //Helper functions for basic tasks
    public final static HelperFunctions helperFunctions=new HelperFunctions();
    //Gravitational Constant
    public final static double G = 6.6743e-20;
    //planetCode is Nasa object code
    private int planetCode;
    //Position for end position of planet(only used for tests)
    private double[] targetPosition;
    //position of the planet in 3D array has[x,y,z] cords
    protected double[] positionalVector = new double[3];
    //velocity of the planet in 3D array has[x,y,z] cords
    protected double[] velocityVector = new double[3];
    //radius of the planet for the visualisation
    protected int radius;
    //mass of the planet in kg
    protected double mass;
    double speed = Math.sqrt(Math.pow(velocityVector[0],2) + Math.pow(velocityVector[1],2) + Math.pow(velocityVector[2],2)); //measured in km/s
    protected double [] acceleration;

//______________________________________________________________________________________________________________________________________________________________________________________________________________________________________
    //Constructors

    //Constructor with velocity
    //default constructor
    public PlanetObject (){

    }
    public PlanetObject (double x, double y, double z, double mass)
    {
        positionalVector[0]=x;
        positionalVector[1]=y;
        positionalVector[2]=z;
        this.mass = mass;
    }

    //Main constructor with all important variables
    public PlanetObject(double x, double y, double z, double vx, double vy, double vz, double mass)
    {
        positionalVector[0]=x;
        positionalVector[1]=y;
        positionalVector[2]=z;
        velocityVector[0] = vx;
        velocityVector[1] = vy;
        velocityVector[2] = vz;
        this.mass = mass;
    }

    //planetCode only constructor
    //Constructor for the api that later adds the values
    public PlanetObject(int planetCode, double mass)
    {
        this.planetCode = planetCode;
        this.mass=mass;
    }
    public double [] getAcceleration(){
        return acceleration;
    }

    public void setAcceleration(double [] acceleration){
        this.acceleration = acceleration;
    }

    public void initializeAcceleration(){
        acceleration = new double[3];
    }

    //______________________________________________________________________________________________________________________________________________________________________________________________________________________________________
    //Methods


    /**
     * @param other the planet that is interaction with the current planet
     * @return the acceleration vector of the force generated by the attraction between planet 1 and planet 2
     * This function can calculate how much force does planet 2 apply to planet 1 and turn it to acceleration
     * It uses Newtonâ€™s law of universal gravity for 3 dimensions
     *
     */
    public double[] accelerationBetween(PlanetObject other)
    {
        double[] force=new double[3];
        double[] positionalVector;
        double[] acceleration= new double[3];

        positionalVector=helperFunctions.subtract(this.positionalVector,other.getPositionalVector());

        double distance=1/helperFunctions.getDistanceBetweenWithVectors(this.positionalVector,other.getPositionalVector());
        for (int i = 0; i <=2 ; i++)
        {
            force[i]=-G*this.mass*other.getMass()*distance*distance*distance*positionalVector[i];
            acceleration[i]=force[i]/this.mass;
            //System.out.println("Acceleration1 ["+i+"]: "+acceleration[i]);
        }
        //System.out.println(acceleration);
        return acceleration;
    }

    public double accelerationForSolvers(double position1D, PlanetObject otherObject, int i){
        HelperFunctions helperFunctions = new HelperFunctions();
        double force = 0;
        double acceleration = 0;
        double M1 = this.mass;
        double M2 = otherObject.getMass();
        double positionalDifference = 0;
        double [] positionalVector = this.positionalVector;
        double [] otherPositionalVector = otherObject.getPositionalVector();


        positionalDifference = position1D - otherPositionalVector[i];

        double distance = 1/helperFunctions.getDistanceBetweenWithVectors(positionalVector, otherPositionalVector);

        force = -G * M1 * M2 *(Math.pow(distance, 3)) * positionalDifference;
        acceleration = force / M1;

        //System.out.println("Acceleration2 ["+i+"]: "+acceleration);

        return acceleration;
    }

    


    //______________________________________________________________________________________________________________________________________________________________________________________________________________________________________


    // Getters and setters for the properties
    public double getX() {
        return positionalVector[0];
    }
    public double getY() {
        return positionalVector[1];
    }
    public double getZ() {
        return positionalVector[2];
    }
    public double getVx() {
        return velocityVector[0];
    }
    public int getRadius() {return radius;}
    public void setRadius(int radius) {this.radius = radius;}
    public double getVy() {
        return velocityVector[1];
    }
    public double getVz() {return velocityVector[2];}
    public double[] getTargetPosition() {return targetPosition;}
    public void setTargetPosition(double[] targetPosition) {this.targetPosition = targetPosition;}
    public int getPlanetCode() {return planetCode;}
    public double[] getVelocityVector() {return velocityVector;}
    public void setVelocityVector(double[] velocityVector) {this.velocityVector = velocityVector;}
    public void setPlanetCode(int planetCode) {this.planetCode = planetCode;}
    public double[] getPositionalVector() {return positionalVector;}
    public double getMass() {return mass;}
    public void setMass(double mass) {this.mass = mass;}
    public void setPositionalVector(double[] positionalVector) {this.positionalVector = positionalVector;}
}